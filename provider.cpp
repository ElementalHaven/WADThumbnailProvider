#include "provider.h"
#include <shlobj.h>

const byte PLAYPALS[][256][3] = {
	{ // DOOM
		0x00, 0x00, 0x00, 0x1F, 0x17, 0x0B, 0x17, 0x0F, 0x07, 0x4B, 0x4B, 0x4B, 0xFF, 0xFF, 0xFF, 0x1B, 0x1B, 0x1B, 0x13, 0x13, 0x13, 0x0B, 0x0B, 0x0B,
		0x07, 0x07, 0x07, 0x2F, 0x37, 0x1F, 0x23, 0x2B, 0x0F, 0x17, 0x1F, 0x07, 0x0F, 0x17, 0x00, 0x4F, 0x3B, 0x2B, 0x47, 0x33, 0x23, 0x3F, 0x2B, 0x1B,
		0xFF, 0xB7, 0xB7, 0xF7, 0xAB, 0xAB, 0xF3, 0xA3, 0xA3, 0xEB, 0x97, 0x97, 0xE7, 0x8F, 0x8F, 0xDF, 0x87, 0x87, 0xDB, 0x7B, 0x7B, 0xD3, 0x73, 0x73,
		0xCB, 0x6B, 0x6B, 0xC7, 0x63, 0x63, 0xBF, 0x5B, 0x5B, 0xBB, 0x57, 0x57, 0xB3, 0x4F, 0x4F, 0xAF, 0x47, 0x47, 0xA7, 0x3F, 0x3F, 0xA3, 0x3B, 0x3B,
		0x9B, 0x33, 0x33, 0x97, 0x2F, 0x2F, 0x8F, 0x2B, 0x2B, 0x8B, 0x23, 0x23, 0x83, 0x1F, 0x1F, 0x7F, 0x1B, 0x1B, 0x77, 0x17, 0x17, 0x73, 0x13, 0x13,
		0x6B, 0x0F, 0x0F, 0x67, 0x0B, 0x0B, 0x5F, 0x07, 0x07, 0x5B, 0x07, 0x07, 0x53, 0x07, 0x07, 0x4F, 0x00, 0x00, 0x47, 0x00, 0x00, 0x43, 0x00, 0x00,
		0xFF, 0xEB, 0xDF, 0xFF, 0xE3, 0xD3, 0xFF, 0xDB, 0xC7, 0xFF, 0xD3, 0xBB, 0xFF, 0xCF, 0xB3, 0xFF, 0xC7, 0xA7, 0xFF, 0xBF, 0x9B, 0xFF, 0xBB, 0x93,
		0xFF, 0xB3, 0x83, 0xF7, 0xAB, 0x7B, 0xEF, 0xA3, 0x73, 0xE7, 0x9B, 0x6B, 0xDF, 0x93, 0x63, 0xD7, 0x8B, 0x5B, 0xCF, 0x83, 0x53, 0xCB, 0x7F, 0x4F,
		0xBF, 0x7B, 0x4B, 0xB3, 0x73, 0x47, 0xAB, 0x6F, 0x43, 0xA3, 0x6B, 0x3F, 0x9B, 0x63, 0x3B, 0x8F, 0x5F, 0x37, 0x87, 0x57, 0x33, 0x7F, 0x53, 0x2F,
		0x77, 0x4F, 0x2B, 0x6B, 0x47, 0x27, 0x5F, 0x43, 0x23, 0x53, 0x3F, 0x1F, 0x4B, 0x37, 0x1B, 0x3F, 0x2F, 0x17, 0x33, 0x2B, 0x13, 0x2B, 0x23, 0x0F,
		0xEF, 0xEF, 0xEF, 0xE7, 0xE7, 0xE7, 0xDF, 0xDF, 0xDF, 0xDB, 0xDB, 0xDB, 0xD3, 0xD3, 0xD3, 0xCB, 0xCB, 0xCB, 0xC7, 0xC7, 0xC7, 0xBF, 0xBF, 0xBF,
		0xB7, 0xB7, 0xB7, 0xB3, 0xB3, 0xB3, 0xAB, 0xAB, 0xAB, 0xA7, 0xA7, 0xA7, 0x9F, 0x9F, 0x9F, 0x97, 0x97, 0x97, 0x93, 0x93, 0x93, 0x8B, 0x8B, 0x8B,
		0x83, 0x83, 0x83, 0x7F, 0x7F, 0x7F, 0x77, 0x77, 0x77, 0x6F, 0x6F, 0x6F, 0x6B, 0x6B, 0x6B, 0x63, 0x63, 0x63, 0x5B, 0x5B, 0x5B, 0x57, 0x57, 0x57,
		0x4F, 0x4F, 0x4F, 0x47, 0x47, 0x47, 0x43, 0x43, 0x43, 0x3B, 0x3B, 0x3B, 0x37, 0x37, 0x37, 0x2F, 0x2F, 0x2F, 0x27, 0x27, 0x27, 0x23, 0x23, 0x23,
		0x77, 0xFF, 0x6F, 0x6F, 0xEF, 0x67, 0x67, 0xDF, 0x5F, 0x5F, 0xCF, 0x57, 0x5B, 0xBF, 0x4F, 0x53, 0xAF, 0x47, 0x4B, 0x9F, 0x3F, 0x43, 0x93, 0x37,
		0x3F, 0x83, 0x2F, 0x37, 0x73, 0x2B, 0x2F, 0x63, 0x23, 0x27, 0x53, 0x1B, 0x1F, 0x43, 0x17, 0x17, 0x33, 0x0F, 0x13, 0x23, 0x0B, 0x0B, 0x17, 0x07,
		0xBF, 0xA7, 0x8F, 0xB7, 0x9F, 0x87, 0xAF, 0x97, 0x7F, 0xA7, 0x8F, 0x77, 0x9F, 0x87, 0x6F, 0x9B, 0x7F, 0x6B, 0x93, 0x7B, 0x63, 0x8B, 0x73, 0x5B,
		0x83, 0x6B, 0x57, 0x7B, 0x63, 0x4F, 0x77, 0x5F, 0x4B, 0x6F, 0x57, 0x43, 0x67, 0x53, 0x3F, 0x5F, 0x4B, 0x37, 0x57, 0x43, 0x33, 0x53, 0x3F, 0x2F,
		0x9F, 0x83, 0x63, 0x8F, 0x77, 0x53, 0x83, 0x6B, 0x4B, 0x77, 0x5F, 0x3F, 0x67, 0x53, 0x33, 0x5B, 0x47, 0x2B, 0x4F, 0x3B, 0x23, 0x43, 0x33, 0x1B,
		0x7B, 0x7F, 0x63, 0x6F, 0x73, 0x57, 0x67, 0x6B, 0x4F, 0x5B, 0x63, 0x47, 0x53, 0x57, 0x3B, 0x47, 0x4F, 0x33, 0x3F, 0x47, 0x2B, 0x37, 0x3F, 0x27,
		0xFF, 0xFF, 0x73, 0xEB, 0xDB, 0x57, 0xD7, 0xBB, 0x43, 0xC3, 0x9B, 0x2F, 0xAF, 0x7B, 0x1F, 0x9B, 0x5B, 0x13, 0x87, 0x43, 0x07, 0x73, 0x2B, 0x00,
		0xFF, 0xFF, 0xFF, 0xFF, 0xDB, 0xDB, 0xFF, 0xBB, 0xBB, 0xFF, 0x9B, 0x9B, 0xFF, 0x7B, 0x7B, 0xFF, 0x5F, 0x5F, 0xFF, 0x3F, 0x3F, 0xFF, 0x1F, 0x1F,
		0xFF, 0x00, 0x00, 0xEF, 0x00, 0x00, 0xE3, 0x00, 0x00, 0xD7, 0x00, 0x00, 0xCB, 0x00, 0x00, 0xBF, 0x00, 0x00, 0xB3, 0x00, 0x00, 0xA7, 0x00, 0x00,
		0x9B, 0x00, 0x00, 0x8B, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x73, 0x00, 0x00, 0x67, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x43, 0x00, 0x00,
		0xE7, 0xE7, 0xFF, 0xC7, 0xC7, 0xFF, 0xAB, 0xAB, 0xFF, 0x8F, 0x8F, 0xFF, 0x73, 0x73, 0xFF, 0x53, 0x53, 0xFF, 0x37, 0x37, 0xFF, 0x1B, 0x1B, 0xFF,
		0x00, 0x00, 0xFF, 0x00, 0x00, 0xE3, 0x00, 0x00, 0xCB, 0x00, 0x00, 0xB3, 0x00, 0x00, 0x9B, 0x00, 0x00, 0x83, 0x00, 0x00, 0x6B, 0x00, 0x00, 0x53,
		0xFF, 0xFF, 0xFF, 0xFF, 0xEB, 0xDB, 0xFF, 0xD7, 0xBB, 0xFF, 0xC7, 0x9B, 0xFF, 0xB3, 0x7B, 0xFF, 0xA3, 0x5B, 0xFF, 0x8F, 0x3B, 0xFF, 0x7F, 0x1B,
		0xF3, 0x73, 0x17, 0xEB, 0x6F, 0x0F, 0xDF, 0x67, 0x0F, 0xD7, 0x5F, 0x0B, 0xCB, 0x57, 0x07, 0xC3, 0x4F, 0x00, 0xB7, 0x47, 0x00, 0xAF, 0x43, 0x00,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD7, 0xFF, 0xFF, 0xB3, 0xFF, 0xFF, 0x8F, 0xFF, 0xFF, 0x6B, 0xFF, 0xFF, 0x47, 0xFF, 0xFF, 0x23, 0xFF, 0xFF, 0x00,
		0xA7, 0x3F, 0x00, 0x9F, 0x37, 0x00, 0x93, 0x2F, 0x00, 0x87, 0x23, 0x00, 0x4F, 0x3B, 0x27, 0x43, 0x2F, 0x1B, 0x37, 0x23, 0x13, 0x2F, 0x1B, 0x0B,
		0x00, 0x00, 0x53, 0x00, 0x00, 0x47, 0x00, 0x00, 0x3B, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x23, 0x00, 0x00, 0x17, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
		0xFF, 0x9F, 0x43, 0xFF, 0xE7, 0x4B, 0xFF, 0x7B, 0xFF, 0xFF, 0x00, 0xFF, 0xCF, 0x00, 0xCF, 0x9F, 0x00, 0x9B, 0x6F, 0x00, 0x6B, 0xA7, 0x6B, 0x6B
	},
	{ // HERETIC
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x10, 0x10, 0x10, 0x18, 0x18, 0x18, 0x1F, 0x1F, 0x1F, 0x24, 0x24, 0x24, 0x2C, 0x2C, 0x2C, 0x30, 0x30, 0x30,
		0x37, 0x37, 0x37, 0x3F, 0x3F, 0x3F, 0x46, 0x46, 0x46, 0x4E, 0x4E, 0x4E, 0x56, 0x56, 0x56, 0x5D, 0x5D, 0x5D, 0x65, 0x65, 0x65, 0x6C, 0x6C, 0x6C,
		0x74, 0x74, 0x74, 0x7C, 0x7C, 0x7C, 0x83, 0x83, 0x83, 0x8B, 0x8B, 0x8B, 0x92, 0x92, 0x92, 0x9A, 0x9A, 0x9A, 0xA2, 0xA2, 0xA2, 0xA9, 0xA9, 0xA9,
		0xB1, 0xB1, 0xB1, 0xB8, 0xB8, 0xB8, 0xC0, 0xC0, 0xC0, 0xC8, 0xC8, 0xC8, 0xCF, 0xCF, 0xCF, 0xD2, 0xD2, 0xD2, 0xD7, 0xD7, 0xD7, 0xDE, 0xDE, 0xDE,
		0xE4, 0xE4, 0xE4, 0xEC, 0xEC, 0xEC, 0xF5, 0xF5, 0xF5, 0xFF, 0xFF, 0xFF, 0x32, 0x32, 0x32, 0x3B, 0x3C, 0x3B, 0x45, 0x48, 0x44, 0x4E, 0x50, 0x4D,
		0x58, 0x5D, 0x56, 0x61, 0x64, 0x5F, 0x6D, 0x70, 0x68, 0x74, 0x7B, 0x70, 0x7D, 0x83, 0x79, 0x86, 0x8D, 0x82, 0x90, 0x97, 0x8B, 0x99, 0xA1, 0x94,
		0xA3, 0xAB, 0x9D, 0xAC, 0xB5, 0xA6, 0xB5, 0xBD, 0xB0, 0xBD, 0xC4, 0xB9, 0x14, 0x10, 0x24, 0x18, 0x18, 0x2C, 0x24, 0x24, 0x3C, 0x34, 0x34, 0x50,
		0x44, 0x44, 0x60, 0x58, 0x58, 0x74, 0x6C, 0x6C, 0x88, 0x7C, 0x7C, 0x98, 0x94, 0x94, 0xAC, 0xA4, 0xA4, 0xB8, 0xB4, 0xB8, 0xC8, 0xC0, 0xC4, 0xD0,
		0xD0, 0xD0, 0xD8, 0xE0, 0xE0, 0xE0, 0x1B, 0x0F, 0x08, 0x26, 0x14, 0x0B, 0x31, 0x1B, 0x0E, 0x3D, 0x1F, 0x0E, 0x41, 0x23, 0x12, 0x4A, 0x25, 0x13,
		0x53, 0x2B, 0x13, 0x57, 0x2F, 0x17, 0x5F, 0x33, 0x1B, 0x67, 0x3B, 0x1F, 0x73, 0x43, 0x23, 0x7B, 0x4B, 0x27, 0x83, 0x53, 0x2F, 0x8F, 0x5B, 0x33,
		0x97, 0x63, 0x3B, 0xA0, 0x6C, 0x40, 0xAF, 0x74, 0x4A, 0xB4, 0x7E, 0x51, 0xC0, 0x87, 0x5B, 0xCC, 0x8F, 0x5D, 0xD5, 0x97, 0x67, 0xD8, 0x9F, 0x73,
		0xDC, 0xA7, 0x7E, 0xDF, 0xAF, 0x8A, 0xE3, 0xB7, 0x95, 0xE6, 0xBE, 0xA1, 0xE9, 0xC6, 0xAC, 0xED, 0xCE, 0xB8, 0xF0, 0xD6, 0xC3, 0x3E, 0x28, 0x0B,
		0x4B, 0x32, 0x10, 0x54, 0x3B, 0x17, 0x5F, 0x43, 0x1E, 0x67, 0x4B, 0x26, 0x6E, 0x53, 0x2F, 0x7B, 0x5F, 0x37, 0x89, 0x6B, 0x3E, 0x96, 0x76, 0x4B,
		0xA3, 0x81, 0x54, 0xAB, 0x89, 0x5C, 0xB4, 0x92, 0x65, 0xBC, 0x9A, 0x6D, 0xC4, 0xA2, 0x75, 0xCC, 0xAA, 0x7D, 0xD0, 0xB0, 0x85, 0x25, 0x14, 0x04,
		0x2F, 0x18, 0x04, 0x39, 0x1C, 0x06, 0x44, 0x21, 0x04, 0x4C, 0x24, 0x03, 0x54, 0x28, 0x00, 0x61, 0x2F, 0x02, 0x72, 0x36, 0x00, 0x7D, 0x3F, 0x06,
		0x8D, 0x4B, 0x09, 0x9B, 0x53, 0x11, 0xA2, 0x5F, 0x15, 0xA9, 0x67, 0x1A, 0xB4, 0x71, 0x20, 0xBC, 0x7C, 0x14, 0xCC, 0x88, 0x18, 0xDC, 0x94, 0x1C,
		0xEC, 0xA0, 0x17, 0xF4, 0xAC, 0x2F, 0xFC, 0xBB, 0x39, 0xFC, 0xC2, 0x46, 0xFB, 0xC9, 0x53, 0xFB, 0xD0, 0x61, 0xFB, 0xD6, 0x6E, 0xFB, 0xDD, 0x7B,
		0xFA, 0xE4, 0x88, 0x9D, 0x33, 0x04, 0xAA, 0x41, 0x02, 0xB9, 0x56, 0x04, 0xD5, 0x76, 0x04, 0xEC, 0xA4, 0x03, 0xF8, 0xBE, 0x03, 0xFF, 0xD8, 0x2B,
		0xFF, 0xFF, 0x00, 0x43, 0x00, 0x00, 0x4F, 0x00, 0x00, 0x5B, 0x00, 0x00, 0x67, 0x00, 0x00, 0x73, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x8B, 0x00, 0x00,
		0x9B, 0x00, 0x00, 0xA7, 0x00, 0x00, 0xB3, 0x00, 0x00, 0xBF, 0x00, 0x00, 0xCB, 0x00, 0x00, 0xD7, 0x00, 0x00, 0xE3, 0x00, 0x00, 0xEF, 0x00, 0x00,
		0xFF, 0x00, 0x00, 0xFF, 0x34, 0x34, 0xFF, 0x4A, 0x4A, 0xFF, 0x5F, 0x5F, 0xFF, 0x7B, 0x7B, 0xFF, 0x9B, 0x9B, 0xFF, 0xB3, 0xB3, 0xFF, 0xC9, 0xC9,
		0xFF, 0xD7, 0xD7, 0x3C, 0x0C, 0x58, 0x50, 0x08, 0x6C, 0x68, 0x08, 0x80, 0x80, 0x00, 0x90, 0x98, 0x00, 0xB0, 0xB8, 0x00, 0xE0, 0xD8, 0x2C, 0xFC,
		0xE0, 0x78, 0xF0, 0x25, 0x06, 0x81, 0x3C, 0x21, 0x93, 0x52, 0x3D, 0xA5, 0x69, 0x58, 0xB7, 0x80, 0x74, 0xC9, 0x97, 0x8F, 0xDB, 0xAD, 0xAB, 0xED,
		0xC4, 0xC6, 0xFF, 0x02, 0x04, 0x29, 0x02, 0x05, 0x31, 0x06, 0x08, 0x39, 0x02, 0x05, 0x41, 0x02, 0x05, 0x4F, 0x00, 0x04, 0x58, 0x00, 0x04, 0x60,
		0x00, 0x04, 0x68, 0x02, 0x05, 0x79, 0x02, 0x05, 0x89, 0x06, 0x09, 0x9F, 0x0C, 0x10, 0xB8, 0x20, 0x28, 0xC8, 0x38, 0x3C, 0xDC, 0x50, 0x50, 0xFD,
		0x50, 0x6C, 0xFC, 0x50, 0x88, 0xFC, 0x50, 0xA4, 0xFC, 0x50, 0xC4, 0xFC, 0x48, 0xDC, 0xFC, 0x50, 0xEC, 0xFC, 0x54, 0xFC, 0xFC, 0x98, 0xFC, 0xFC,
		0xBC, 0xFC, 0xF4, 0x0B, 0x17, 0x07, 0x13, 0x23, 0x0B, 0x17, 0x33, 0x0F, 0x1F, 0x43, 0x17, 0x27, 0x53, 0x1B, 0x2F, 0x63, 0x23, 0x37, 0x73, 0x2B,
		0x3F, 0x83, 0x2F, 0x43, 0x93, 0x37, 0x4B, 0x9F, 0x3F, 0x53, 0xAF, 0x47, 0x5B, 0xBF, 0x4F, 0x5F, 0xCF, 0x57, 0x67, 0xDF, 0x5F, 0x6F, 0xEF, 0x67,
		0x77, 0xFF, 0x6F, 0x17, 0x1F, 0x17, 0x1B, 0x23, 0x1B, 0x1F, 0x2B, 0x1F, 0x23, 0x33, 0x23, 0x2B, 0x37, 0x2B, 0x2F, 0x3F, 0x2F, 0x33, 0x47, 0x33,
		0x3B, 0x4B, 0x37, 0x3F, 0x53, 0x3B, 0x43, 0x5B, 0x43, 0x4B, 0x5F, 0x47, 0x4F, 0x67, 0x4B, 0x57, 0x6F, 0x4F, 0x5B, 0x73, 0x53, 0x5F, 0x7B, 0x57,
		0x67, 0x83, 0x5F, 0xFF, 0xDF, 0x00, 0xFF, 0xBF, 0x00, 0xFF, 0x9F, 0x00, 0xFF, 0x7F, 0x00, 0xFF, 0x5F, 0x00, 0xFF, 0x3F, 0x00, 0xF4, 0x0E, 0x03,
		0x37, 0x00, 0x00, 0x2F, 0x00, 0x00, 0x27, 0x00, 0x00, 0x17, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0B, 0x0B, 0x0B, 0x07, 0x07, 0x07, 0xFF, 0xFF, 0xFF
	}
};

#ifdef _DEBUG
void dumbErrorReport(wchar_t* message) {
	wchar_t filename[MAX_PATH];
	wsprintf(filename, L"C:/DOOM/%s.txt", message);
	HANDLE f = CreateFileW(filename, GENERIC_WRITE, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);
	if(f != INVALID_HANDLE_VALUE) CloseHandle(f);
}
#endif

HRESULT WADThumbnailProvider::createMemoryStream() {
	wadStart.QuadPart = 0;
	ULONG totalBytesRead = 0;
	ULONG bytesRead = 0;
	ULONG bufferSize = BUFFER_SIZE_DEFAULT;
	byte* buffer = (byte*) malloc(bufferSize);
	HRESULT hr;
	do {
		if(totalBytesRead + BUFFER_BLOCK_SIZE > bufferSize) {
			bufferSize += BUFFER_SIZE_INCREMENT;
			buffer = (byte*) realloc(buffer, bufferSize);
		}
		hr = stream->Read(buffer + totalBytesRead, BUFFER_BLOCK_SIZE, &bytesRead);
		totalBytesRead += bytesRead;
	} while(bytesRead != 0 && totalBytesRead < BUFFER_SIZE_MAX);
	if(bytesRead > 0) hr = S_OK;
	IStream* tmp = SHCreateMemStream(buffer, totalBytesRead);
	free(buffer);
	//ULARGE_INTEGER maxSize = { BUFFER_SIZE_MAX, 0 };
	//HRESULT hr = stream->CopyTo(tmp, maxSize, nullptr, nullptr);
	if(SUCCEEDED(hr)) {
		stream->Release();
		stream = tmp;
		LARGE_INTEGER offset = { 0 };
		hr = stream->Seek(offset, STREAM_SEEK_SET, nullptr);
		//if(FAILED(hr)) dumbErrorReport(L"MEM_SEEK_FAIL");
	}
#ifdef _DEBUG
	else {
		dumbErrorReport(L"COPY_TO_FAIL");
	}
#endif
	return hr;
}

HRESULT WADThumbnailProvider::determineFileOffsetsAndGame() {
	WADFileHeader header;
	ULONG bytesRead;

	HRESULT hr = stream->Read(&header, sizeof(WADFileHeader), &bytesRead);
	if(FAILED(hr)) return hr;
	if(header.magic != MAGIC_IWAD && header.magic != MAGIC_PWAD) return E_FAIL;

	WADLumpInfo* lumps = new WADLumpInfo[header.lumpCount];
	// holy shit. MSVC doesnt support a C99 feature until VC++ 13 and apparently it was bugged until SP3 even then
	LARGE_INTEGER offset;
	offset.QuadPart = wadStart.QuadPart + header.dirOffset;
	hr = stream->Seek(offset, STREAM_SEEK_SET, nullptr);
	if(SUCCEEDED(hr)) {
		hr = stream->Read(lumps, sizeof(WADLumpInfo) * header.lumpCount, &bytesRead);
		if(SUCCEEDED(hr)) {
			WADLumpInfo* loopEnd = lumps + header.lumpCount;
			for(WADLumpInfo* info = lumps; info < loopEnd; ++info) {
				// TODO: maybe check lump names to determine game and determine default playpal from that
				switch(info->name.ival) {
				case LUMPNAME('P','L','A','Y','P','A','L','\0'):
					playpal = wadStart.LowPart + info->offset;
					break;
				case LUMPNAME('T','I','T','L','E','P','I','C'):
					titlepic = wadStart.LowPart + info->offset;
					break;
				case LUMPNAME('T','I','T','L','E','\0','\0','\0'):
					titlepic = wadStart.LowPart + info->offset;
					heretic = true;
					if(playpal == PLAYPAL_TYPE_DOOM) playpal = PLAYPAL_TYPE_HERETIC;
					break;
				}
			}
			if(titlepic == NULL) return E_FAIL;
		}
	}

	delete[] lumps;
	return hr;
}

HRESULT WADThumbnailProvider::loadRelevantLumps() {
	HRESULT hr;
	LARGE_INTEGER offset;
	ULONG bytesRead;
	byte palette[256][3];

	// read PLAYPAL
	if(playpal >= sizeof(WADFileHeader)) {
		offset.QuadPart = playpal;
		hr = stream->Seek(offset, STREAM_SEEK_SET, nullptr);
		if(FAILED(hr)) return hr;
		hr = stream->Read(palette, sizeof(palette), &bytesRead);
		if(FAILED(hr)) return hr;
	} else {
		memcpy(palette, PLAYPALS[playpal], sizeof(palette));
	}
	// swap red and blue so we can do a simple memcpy for each pixel
	for(int i = 0; i < 256; ++i) {
		byte b = palette[i][2];
		palette[i][2] = palette[i][0];
		palette[i][0] = b;
	}

	// read TITLEPIC or TITLE
	offset.QuadPart = titlepic;
	hr = stream->Seek(offset, STREAM_SEEK_SET, nullptr);
	if(FAILED(hr)) return hr;
	hr = heretic ? readTitle(palette) : readTitlepic(palette);
	return hr;
}

HRESULT WADThumbnailProvider::readTitle(byte (&palette)[256][3]) {
	const int pixelStride = 4;
	const int pixelCount = 320 * 200;
	const int imgSize = pixelCount * pixelStride;

	titlepicWidth = 320;
	titlepicHeight = 200;
	byte* pixels = new byte[imgSize];
	
	HRESULT hr;
	byte palIdx;
	ULONG bytesRead;
	byte* p = pixels;
	for(int i = 0; i < pixelCount; ++i, p += 4) {
		hr = stream->Read(&palIdx, 1, &bytesRead);
		if(FAILED(hr)) break;
		memcpy(p, palette[palIdx], 3);
		p[3] = 255;
	}
	bmp = CreateBitmap(titlepicWidth, titlepicHeight, 1, 32, pixels);
	delete[] pixels;
#ifdef _DEBUG
	if(SUCCEEDED(hr)) {
		dumbErrorReport(L"READ_TITLE");
	}
#endif
	return hr;
}

HRESULT WADThumbnailProvider::readTitlepic(byte (&palette)[256][3]) {
	ULONG bytesRead;
	LARGE_INTEGER offset;

	WADPictureHeader header;
	HRESULT hr = stream->Read(&header, sizeof(WADPictureHeader), &bytesRead);
	if(FAILED(hr)) return hr;
	titlepicWidth = header.width;
	titlepicHeight = header.height;
	DWORD* columns = new DWORD[titlepicWidth];
	hr = stream->Read(columns, 4 * titlepicWidth, &bytesRead);
	if(SUCCEEDED(hr)) {
		const int pixelStride = 4;
		const int scanlineStride = titlepicWidth * pixelStride;
		byte* pixels = new byte[titlepicHeight * scanlineStride];
		for(int x = 0; x < titlepicWidth; ++x) {
			offset.QuadPart = titlepic + columns[x];
			hr = stream->Seek(offset, STREAM_SEEK_SET, nullptr);
			if(FAILED(hr)) break;
			byte y, palIdx;
			short count;
			while(true) {
				hr = stream->Read(&y, 1, &bytesRead);
				if(FAILED(hr)) goto cleanup; // or set x to titlepicWidth and break if paranoid of gotos
				if(y == UCHAR_MAX) break;
				hr = stream->Read(&count, 2, &bytesRead);
				if(FAILED(hr)) goto cleanup;
				count &= UCHAR_MAX;
				for(int colIdx = 0, pixIdx = y * scanlineStride + x * pixelStride; colIdx < count; ++colIdx, pixIdx += scanlineStride) {
					hr = stream->Read(&palIdx, 1, &bytesRead);
					if(FAILED(hr)) goto cleanup;
					memcpy(pixels + pixIdx, palette[palIdx], 3);
					pixels[pixIdx + 3] = 255;
				}
				hr = stream->Read(&palIdx, 1, &bytesRead);
				if(FAILED(hr)) goto cleanup;
			}
#ifdef _DEBUG
			dumbErrorReport(L"READ_TITLEPIC");
#endif
		}
cleanup:
		bmp = CreateBitmap(titlepicWidth, titlepicHeight, 1, 32, pixels);
		delete[] pixels;
	}
	delete[] columns;
	return hr;
}

/*
HRESULT WADThumbnailProvider::shrinkBitmap(int width, int height) {
	HDC hdcDst = CreateCompatibleDC(nullptr);
	HDC hdcSrc = CreateCompatibleDC(nullptr);
	if(!hdcDst || !hdcSrc) {
		if(hdcDst) DeleteDC(hdcDst);
		if(hdcSrc) DeleteDC(hdcSrc);
		return E_HANDLE;
	}

	HBITMAP bmpDst = CreateBitmap(width, height, 1, 32, nullptr);

	SelectObject(hdcDst, bmpDst);
	SelectObject(hdcSrc, bmp);

	SetStretchBltMode(hdcDst, HALFTONE);
	SetBrushOrgEx(hdcDst, 0, 0, nullptr);
	StretchBlt(hdcDst, 0, 0, width, height, hdcSrc, 0, 0, titlepicWidth, titlepicHeight, SRCCOPY);

	DeleteObject(bmp);
	bmp = bmpDst;

	DeleteDC(hdcDst);
	DeleteDC(hdcSrc);

	return S_OK;
}
*/

WADThumbnailProvider::WADThumbnailProvider() : references(1), stream(nullptr) {}

WADThumbnailProvider::~WADThumbnailProvider() {
	if(stream) stream->Release();
}

IFACEMETHODIMP WADThumbnailProvider::Initialize(IStream* pstream, DWORD grfMode) {
	HRESULT hr = E_UNEXPECTED;
	if(!stream) {
		hr = pstream->QueryInterface(&stream);
		if(SUCCEEDED(hr)) {
			LARGE_INTEGER offset = { 0, 0 };
			hr = stream->Seek(offset, STREAM_SEEK_CUR, &wadStart);
			if(FAILED(hr)) {
				hr = createMemoryStream();
			}
			heretic = false;
			titlepic = NULL;
			playpal = PLAYPAL_TYPE_DOOM;
			bmp = nullptr;
		}
	}
	return hr;
}

IFACEMETHODIMP WADThumbnailProvider::GetThumbnail(UINT maxSize, HBITMAP *phbmp, WTS_ALPHATYPE *pdwAlpha) {
	HRESULT hr = determineFileOffsetsAndGame();
	if(FAILED(hr)) return hr;
	hr = loadRelevantLumps();
	if(SUCCEEDED(hr)) {
		/* Microsoft's example Thumbnail Provider never even uses the maxSize(cx) param. perhaps we can just not bother and it will both fix the black image issue and reduce the dll size
		if(max(titlepicWidth, titlepicHeight) > maxSize) {
			int width, height;
			if(titlepicWidth > titlepicHeight) {
				width = maxSize;
				height = titlepicHeight * maxSize / titlepicWidth;
			} else {
				width = titlepicWidth * maxSize / titlepicHeight;
				height = maxSize;
			}
			hr = shrinkBitmap(width, height);
		}
		//*/
		if(SUCCEEDED(hr)) {
			*pdwAlpha = WTSAT_RGB;
			*phbmp = bmp;
			hr = S_OK;
		}
	}
	return hr;
}

IFACEMETHODIMP_(ULONG) WADThumbnailProvider::AddRef() {
	return ++references;
}

IFACEMETHODIMP_(ULONG) WADThumbnailProvider::Release() {
	ULONG count = --references;
	if(count == 0) {
		delete this;
	}
	return count;
}

IFACEMETHODIMP WADThumbnailProvider::QueryInterface(REFIID iid, void** object) {
	static const QITAB tabs[] = {
		QITABENT(WADThumbnailProvider, IInitializeWithStream),
		QITABENT(WADThumbnailProvider, IThumbnailProvider),
		{ 0 }
	};
	return QISearch(this, tabs, iid, object);
}

HRESULT WADThumbnailProvider_CreateInstance(REFIID iid, void** object) {
	WADThumbnailProvider* provider = new (std::nothrow) WADThumbnailProvider();
	HRESULT hr = provider ? S_OK : E_OUTOFMEMORY;
	if(SUCCEEDED(hr)) {
		hr = provider->QueryInterface(iid, object);
		provider->Release();
	}
	return hr;
}

#ifdef _DEBUG
#include <gdiplus.h>
#pragma comment(lib, "gdiplus.lib")

extern HINSTANCE g_hInst;

int GetEncoderClsid(const WCHAR* format, CLSID* pClsid) {
	UINT  num = 0;          // number of image encoders
	UINT  size = 0;         // size of the image encoder array in bytes

	Gdiplus::ImageCodecInfo* pImageCodecInfo = NULL;

	Gdiplus::GetImageEncodersSize(&num, &size);
	if(size == 0)
		return -1;  // Failure

	pImageCodecInfo = (Gdiplus::ImageCodecInfo*) (malloc(size));
	if(pImageCodecInfo == NULL) {
		return -1;  // Failure
	}

	GetImageEncoders(num, size, pImageCodecInfo);

	for(UINT j = 0; j < num; ++j) {
		if(wcscmp(pImageCodecInfo[j].MimeType, format) == 0) {
			*pClsid = pImageCodecInfo[j].Clsid;
			free(pImageCodecInfo);
			return j;  // Success
		}    
	}

	free(pImageCodecInfo);
	return -1;  // Failure
}

int CALLBACK WinMain(HINSTANCE inst, HINSTANCE, LPSTR, int) {
	g_hInst = inst;
	IStream* stream;
	HRESULT hr = SHCreateStreamOnFileEx(L"C:/DOOM/IWADS/HERETIC1.WAD", STGM_READ, FILE_ATTRIBUTE_NORMAL, FALSE, NULL, &stream);
	if(SUCCEEDED(hr)) {
		WADThumbnailProvider* provider = new WADThumbnailProvider();
		hr = provider->Initialize(stream, 0);
		if(SUCCEEDED(hr)) {
			HBITMAP bmp;
			WTS_ALPHATYPE alphaType;
			hr = provider->GetThumbnail(128, &bmp, &alphaType);
			if(SUCCEEDED(hr)) {
				Gdiplus::GdiplusStartupInput gdiplusStartupInput;
				ULONG_PTR gdiplusToken;
				Gdiplus::GdiplusStartup(&gdiplusToken, &gdiplusStartupInput, NULL);

				WCHAR path[MAX_PATH];
				PWSTR desktop;
				SHGetKnownFolderPath(FOLDERID_Desktop, 0, NULL, &desktop);
				wsprintf(path, L"%s/debug_result.png", desktop);
				Gdiplus::Bitmap* gdibmp = new Gdiplus::Bitmap(bmp, NULL);
				CLSID clsId;
				GetEncoderClsid(L"image/png", &clsId);
				hr = (HRESULT) gdibmp->Save(path, &clsId);
				delete gdibmp;

				Gdiplus::GdiplusShutdown(gdiplusToken);

				DeleteObject(bmp);
			}
		}
		provider->Release();
	}
	return hr;
}
#endif